{"version":3,"file":"boundingInfoHelper.js","sourceRoot":"","sources":["../../../../../dev/core/src/Culling/Helper/boundingInfoHelper.ts"],"names":[],"mappings":"AAKA;;;;;;;;;;GAUG;AACH,MAAM,OAAO,kBAAkB;IAI3B;;;OAGG;IACH,YAAmB,MAAsB;QACrC,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;IAC1B,CAAC;IAED;;;;OAIG;IACI,KAAK,CAAC,YAAY,CAAC,MAAqC;QAC3D,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;YACjB,IAAI,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC,qBAAqB,EAAE;gBAC9C,MAAM,MAAM,GAAG,MAAM,MAAM,CAAC,+BAA+B,CAAC,CAAC;gBAC7D,IAAI,CAAC,SAAS,GAAG,IAAI,MAAM,CAAC,2BAA2B,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;aACzE;iBAAM,IAAI,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC,yBAAyB,EAAE;gBACzD,MAAM,MAAM,GAAG,MAAM,MAAM,CAAC,mCAAmC,CAAC,CAAC;gBACjE,IAAI,CAAC,SAAS,GAAG,IAAI,MAAM,CAAC,+BAA+B,CAAC,IAAI,CAAC,OAAqB,CAAC,CAAC;aAC3F;iBAAM;gBACH,MAAM,IAAI,KAAK,CAAC,qEAAqE,CAAC,CAAC;aAC1F;SACJ;QAED,OAAO,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;IAC/C,CAAC;IAED;;OAEG;IACI,OAAO;QACV,IAAI,CAAC,SAAS,CAAC,OAAO,EAAE,CAAC;IAC7B,CAAC;CACJ","sourcesContent":["import type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { AbstractEngine } from \"core/Engines/abstractEngine\";\r\nimport type { IBoundingInfoHelperPlatform } from \"./IBoundingInfoHelperPlatform\";\r\nimport type { ThinEngine } from \"core/Engines\";\r\n\r\n/**\r\n * Utility class to help with bounding info management\r\n * #BCNJD4#41 =\\> does not use the BoundingInfoHelper class, performs calculations on the CPU\r\n * #BCNJD4#37 =\\> same as #41 but use the BoundingInfoHelper class\r\n * #BCNJD4#40 =\\> example with bones and morphs (webGL2)\r\n * #BCNJD4#42 =\\> example with bones and morphs (webGPU)\r\n * #HPV2TZ#475 =\\> only morph (webGL2)\r\n * #HPV2TZ#476 =\\> only morph (webGPU)\r\n * #B8B8Z2#8 =\\> Large scale test (webGL2)\r\n * #B8B8Z2#9 =\\> Large scale test (webGPU)\r\n */\r\nexport class BoundingInfoHelper {\r\n    private _platform: IBoundingInfoHelperPlatform;\r\n    private _engine: AbstractEngine;\r\n\r\n    /**\r\n     * Creates a new BoundingInfoHelper\r\n     * @param engine defines the engine to use\r\n     */\r\n    public constructor(engine: AbstractEngine) {\r\n        this._engine = engine;\r\n    }\r\n\r\n    /**\r\n     * Compute the bounding info of a mesh / array of meshes using shaders\r\n     * @param target defines the mesh(es) to update\r\n     * @returns a promise that resolves when the bounding info is/are computed\r\n     */\r\n    public async computeAsync(target: AbstractMesh | AbstractMesh[]): Promise<void> {\r\n        if (!this._platform) {\r\n            if (this._engine.getCaps().supportComputeShaders) {\r\n                const module = await import(\"./computeShaderBoundingHelper\");\r\n                this._platform = new module.ComputeShaderBoundingHelper(this._engine);\r\n            } else if (this._engine.getCaps().supportTransformFeedbacks) {\r\n                const module = await import(\"./transformFeedbackBoundingHelper\");\r\n                this._platform = new module.TransformFeedbackBoundingHelper(this._engine as ThinEngine);\r\n            } else {\r\n                throw new Error(\"Your engine does not support Compute Shaders or Transform Feedbacks\");\r\n            }\r\n        }\r\n\r\n        return this._platform.processAsync(target);\r\n    }\r\n\r\n    /**\r\n     * Dispose and release associated resources\r\n     */\r\n    public dispose(): void {\r\n        this._platform.dispose();\r\n    }\r\n}\r\n"]}